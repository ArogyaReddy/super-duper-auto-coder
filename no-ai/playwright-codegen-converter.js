#!/usr/bin/env node
/**
 * NO-AI PLAYWRIGHT CODEGEN TO TEST ARTIFACTS CONVERTER
 * 
 * Converts Playwright CodeGen recordings to SBS_Automation test artifacts
 * Usage: node playwright-codegen-converter.js <recording-file> <base-name>
 */

const fs = require('fs');
const path = require('path');

function convertPlaywrightToSBS(recordingFile, baseName) {
    const recordingContent = fs.readFileSync(recordingFile, 'utf8');
    
    // Extract actions from Playwright recording
    const actions = extractActionsFromRecording(recordingContent);
    
    // Generate SBS-compliant artifacts
    const feature = generateFeatureFile(actions, baseName);
    const steps = generateStepsFile(actions, baseName);
    const page = generatePageFile(actions, baseName);
    
    // Write files to SBS_Automation structure
    const featureFile = path.resolve(__dirname, `../SBS_Automation/features/${baseName}.feature`);
    const stepsFile = path.resolve(__dirname, `../SBS_Automation/steps/${baseName}-steps.js`);
    const pageFile = path.resolve(__dirname, `../SBS_Automation/pages/common/${baseName}-page.js`);
    
    fs.writeFileSync(featureFile, feature);
    fs.writeFileSync(stepsFile, steps);
    fs.writeFileSync(pageFile, page);
    
    console.log(`✅ Feature file generated: ${featureFile}`);
    console.log(`✅ Steps file generated: ${stepsFile}`);
    console.log(`✅ Page file generated: ${pageFile}`);
}

function extractActionsFromRecording(content) {
    const actions = [];
    const lines = content.split('\n');
    
    for (const line of lines) {
        const trimmed = line.trim();
        
        // Extract goto actions
        if (trimmed.includes('page.goto(')) {
            const urlMatch = trimmed.match(/page\.goto\(['"]([^'"]+)['"]/);
            if (urlMatch) {
                actions.push({
                    type: 'navigate',
                    url: urlMatch[1],
                    description: `Navigate to ${urlMatch[1]}`
                });
            }
        }
        
        // Extract click actions
        if (trimmed.includes('page.click(')) {
            const selectorMatch = trimmed.match(/page\.click\(\s*['"]([^'"]+)['"]\s*\)/);
            if (selectorMatch) {
                actions.push({
                    type: 'click',
                    selector: selectorMatch[1],
                    description: `Click element ${selectorMatch[1]}`
                });
            }
        }
        
        // Extract fill actions
        if (trimmed.includes('page.fill(')) {
            const match = trimmed.match(/page\.fill\(\s*['"]([^'"]+)['"],\s*['"]([^'"]+)['"]\s*\)/);
            if (match) {
                actions.push({
                    type: 'fill',
                    selector: match[1],
                    value: match[2],
                    description: `Fill ${match[1]} with ${match[2]}`
                });
            }
        }
        
        // Extract waitForSelector actions
        if (trimmed.includes('page.waitForSelector(')) {
            const selectorMatch = trimmed.match(/page\.waitForSelector\(\s*['"]([^'"]+)['"]\s*\)/);
            if (selectorMatch) {
                actions.push({
                    type: 'wait',
                    selector: selectorMatch[1],
                    description: `Wait for element ${selectorMatch[1]}`
                });
            }
        }
    }
    
    return actions;
}

function generateFeatureFile(actions, baseName) {
    const featureName = baseName.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    
    let feature = `@Team:SBSBusinessContinuity
@jira=AUTO-${Date.now()}
@parentSuite:AutoGenerated
@regression @critical
Feature: ${featureName}
  As a user
  I want to perform recorded actions
  So that I can validate the application workflow

  Background:
    Given the application is available

  @smoke @RecordedWorkflow
  Scenario: Execute recorded workflow
`;

    let stepNumber = 1;
    actions.forEach(action => {
        switch (action.type) {
            case 'navigate':
                feature += `    When I navigate to "${action.url}"\n`;
                break;
            case 'click':
                feature += `    And I click on element "${action.selector}"\n`;
                break;
            case 'fill':
                feature += `    And I fill "${action.selector}" with "${action.value}"\n`;
                break;
            case 'wait':
                feature += `    Then I should see element "${action.selector}"\n`;
                break;
        }
        stepNumber++;
    });
    
    feature += `    Then the workflow should complete successfully\n`;
    
    return feature;
}

function generateStepsFile(actions, baseName) {
    const className = baseName.replace(/-/g, '').replace(/\b\w/g, l => l.toUpperCase()) + 'Page';
    
    let steps = `const { Given, When, Then } = require('@cucumber/cucumber');
const { assert } = require('chai');
const By = require('./../../support/By.js');
const helpers = require('./../../support/helpers.js');
const ${className} = require('../../pages/common/${baseName}-page');

let pageObject;

Given('the application is available', { timeout: 60 * 1000 }, async function () {
  pageObject = new ${className}(this.page);
  const result = await pageObject.ensureApplicationAvailable();
  assert.isTrue(result, 'Application should be available');
});

`;

    // Generate unique steps for each action type
    const uniqueActions = getUniqueActionsByType(actions);
    
    uniqueActions.forEach(action => {
        switch (action.type) {
            case 'navigate':
                steps += `When('I navigate to {string}', { timeout: 60 * 1000 }, async function (url) {
  await pageObject.navigateToUrl(url);
});

`;
                break;
            case 'click':
                steps += `When('I click on element {string}', { timeout: 60 * 1000 }, async function (selector) {
  await pageObject.clickElement(selector);
});

`;
                break;
            case 'fill':
                steps += `When('I fill {string} with {string}', { timeout: 60 * 1000 }, async function (selector, value) {
  await pageObject.fillElement(selector, value);
});

`;
                break;
            case 'wait':
                steps += `Then('I should see element {string}', { timeout: 60 * 1000 }, async function (selector) {
  const isVisible = await pageObject.isElementVisible(selector);
  assert.isTrue(isVisible, \`Element \${selector} should be visible\`);
});

`;
                break;
        }
    });
    
    steps += `Then('the workflow should complete successfully', { timeout: 60 * 1000 }, async function () {
  const result = await pageObject.verifyWorkflowCompletion();
  assert.isTrue(result, 'Workflow should complete successfully');
});

module.exports = { pageObject };`;
    
    return steps;
}

function generatePageFile(actions, baseName) {
    const className = baseName.replace(/-/g, '').replace(/\b\w/g, l => l.toUpperCase()) + 'Page';
    
    // Extract unique selectors for constants
    const selectors = [...new Set(actions
        .filter(a => a.selector)
        .map(a => a.selector)
    )];
    
    let page = `const By = require('./../../support/By.js');
let BasePage = require('../common/base-page');
const helpers = require('./../../support/helpers.js');

// Selectors extracted from recorded actions
`;
    
    selectors.forEach(selector => {
        const constantName = selectorToConstantName(selector);
        if (selector.startsWith('[data-test') || selector.startsWith('#') || selector.startsWith('.')) {
            page += `const ${constantName} = By.css('${selector}');\n`;
        } else {
            page += `const ${constantName} = By.xpath('//*[contains(@*, "${selector}")]');\n`;
        }
    });
    
    page += `
class ${className} extends BasePage {
  constructor(page) {
    super(page);
    this.page = page;
  }

  async ensureApplicationAvailable() {
    try {
      await this.page.waitForLoadState('networkidle');
      return true;
    } catch (error) {
      console.error('Application not available:', error.message);
      return false;
    }
  }

  async navigateToUrl(url) {
    await this.page.goto(url);
    await this.page.waitForLoadState('networkidle');
  }

  async clickElement(selector) {
    await this.page.click(selector);
  }

  async fillElement(selector, value) {
    await this.page.fill(selector, value);
  }

  async isElementVisible(selector) {
    try {
      return await this.page.isVisible(selector);
    } catch (error) {
      return false;
    }
  }

  async verifyWorkflowCompletion() {
    try {
      // Add specific verification logic based on your application
      await this.page.waitForLoadState('networkidle');
      return true;
    } catch (error) {
      console.error('Workflow verification failed:', error.message);
      return false;
    }
  }
}

module.exports = ${className};`;
    
    return page;
}

function getUniqueActionsByType(actions) {
    const types = [...new Set(actions.map(a => a.type))];
    return types.map(type => actions.find(a => a.type === type));
}

function selectorToConstantName(selector) {
    return selector
        .replace(/[^a-zA-Z0-9]/g, '_')
        .replace(/_+/g, '_')
        .replace(/^_|_$/g, '')
        .toUpperCase();
}

// Main execution
const recordingFile = process.argv[2] || path.resolve(__dirname, '../requirements/record/login-workflow.txt');
const baseName = process.argv[3] || path.basename(recordingFile, path.extname(recordingFile));

if (!fs.existsSync(recordingFile)) {
    console.error(`❌ Recording file not found: ${recordingFile}`);
    process.exit(1);
}

convertPlaywrightToSBS(recordingFile, baseName);
